{"ast":null,"code":"export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20;\nexport const createStage = () => Array.from(Array(STAGE_HEIGHT), () => Array(STAGE_WIDTH).fill([0, 'clear']));\nexport const checkCollision = (player, stage, {\n  x: moveX,\n  y: moveY\n}) => {\n  for (let y = 0; y < player.tetromino.length; y += 1) {\n    for (let x = 0; x < player.tetromino[y].length; x += 1) {\n      //checking if any cells inside the tetris block coincide w/any cells in the playing field\n      if (player.tetromino[y][x] !== 0) {\n        if ( //2. Check that movement is inside the height of the game field (aka y)\n        !stage[y + player.pos.y + moveY] || //3. Check that movement is inside the game area width (aka x)\n        !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] || //4. Check that the cell we move to isn't set to clear\n        stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !== 'clear') {\n          return true;\n        }\n      }\n    }\n  } // 5. If everything above is false\n\n\n  return false;\n};","map":{"version":3,"sources":["/Users/melanierogoff/Desktop/pikatetris/src/gameHelpers.js"],"names":["STAGE_WIDTH","STAGE_HEIGHT","createStage","Array","from","fill","checkCollision","player","stage","x","moveX","y","moveY","tetromino","length","pos"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAG,EAApB;AACP,OAAO,MAAMC,YAAY,GAAG,EAArB;AAEP,OAAO,MAAMC,WAAW,GAAG,MACzBC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACF,YAAD,CAAhB,EAAgC,MAAME,KAAK,CAACH,WAAD,CAAL,CAAmBK,IAAnB,CAAwB,CAAC,CAAD,EAAI,OAAJ,CAAxB,CAAtC,CADK;AAGH,OAAO,MAAMC,cAAc,GAAG,CAACC,MAAD,EAASC,KAAT,EAAgB;AAAEC,EAAAA,CAAC,EAAEC,KAAL;AAAYC,EAAAA,CAAC,EAAEC;AAAf,CAAhB,KAA2C;AACrE,OAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACM,SAAP,CAAiBC,MAArC,EAA6CH,CAAC,IAAI,CAAlD,EAAqD;AACjD,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACM,SAAP,CAAiBF,CAAjB,EAAoBG,MAAxC,EAAgDL,CAAC,IAAI,CAArD,EAAwD;AACpD;AACA,UAAIF,MAAM,CAACM,SAAP,CAAiBF,CAAjB,EAAoBF,CAApB,MAA2B,CAA/B,EAAkC;AAC9B,aACA;AACA,SAACD,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAN,IAEA;AACA,SAACJ,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAL,CAAgCH,CAAC,GAAGF,MAAM,CAACQ,GAAP,CAAWN,CAAf,GAAmBC,KAAnD,CAHD,IAKA;AACAF,QAAAA,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAL,CAAgCH,CAAC,GAAGF,MAAM,CAACQ,GAAP,CAAWN,CAAf,GAAmBC,KAAnD,EAA0D,CAA1D,MACA,OATA,EAUF;AACA,iBAAO,IAAP;AACD;AACF;AACF;AACF,GApBkE,CAqBnE;;;AACA,SAAO,KAAP;AACD,CAvBE","sourcesContent":["export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20;\n\nexport const createStage = () =>\n  Array.from(Array(STAGE_HEIGHT), () => Array(STAGE_WIDTH).fill([0, 'clear']));\n\n    export const checkCollision = (player, stage, { x: moveX, y: moveY }) => {\n        for (let y = 0; y < player.tetromino.length; y += 1) {\n            for (let x = 0; x < player.tetromino[y].length; x += 1) {\n                //checking if any cells inside the tetris block coincide w/any cells in the playing field\n                if (player.tetromino[y][x] !== 0) {\n                    if (\n                    //2. Check that movement is inside the height of the game field (aka y)\n                    !stage[y + player.pos.y + moveY] ||\n                    \n                    //3. Check that movement is inside the game area width (aka x)\n                    !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n\n                    //4. Check that the cell we move to isn't set to clear\n                    stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !==\n                    'clear'\n                ) {\n                  return true;\n                }\n              }\n            }\n          }\n          // 5. If everything above is false\n          return false;\n        };\n\n"]},"metadata":{},"sourceType":"module"}